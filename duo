#!/usr/bin/env bash

cd "$(dirname "$(realpath "$0")")"

function mutter-feature-enabled {
  dconf read "/org/gnome/mutter/experimental-features"|grep "$1" > /dev/null
}

# 3k model
if mutter-feature-enabled variable-refresh-rate ; then
  preferred_resolution="2880x1800@120.000+vrr"
else
  preferred_resolution="2880x1800@120.000"
fi

ui_scale=1.7475727796554565 # 1.75
if mutter-feature-enabled scale-monitor-framebuffer ; then
  ui_scale=1.7475727796554565 # 1.75
  # y offset = height of resolution / ui_scale (1800/1.7475... = 1030), but better to check via bustle (recording session bus, you are interested in org.gnome.Mutter.DisplayConfig.ApplyMonitorsConfig call. start recording and configure display in gnome display settings)
  y_offset=1030
else
  ui_scale=2
  y_offset=1800
fi

# Touch/stylus device IDs; defaults are overridden by auto-detection when possible.
top_touch_ids=("04f3:2f29" "04f3:425b")
bottom_touch_ids=("04f3:2f2a" "04f3:425a")
top_monitor_connector="eDP-1"
bottom_monitor_connector="eDP-2"
top_monitor_vendor="SDC"
top_monitor_product="0x419d"
top_monitor_serial="0x00000000"
bottom_monitor_vendor="SDC"
bottom_monitor_product="0x419d"
bottom_monitor_serial="0x00000000"

function detect_touch_ids {
  if ! command -v libinput >/dev/null 2>&1; then
    return
  fi

  declare -A id_area
  declare -A id_seen
  local current_id=""
  local current_size=""
  local current_caps=""

  while IFS= read -r line; do
    case "$line" in
      "Device:"*)
        current_id=""
        current_size=""
        current_caps=""
        ;;
      "Id:"*)
        current_id="$(echo "$line" | awk '{print $2}')"
        ;;
      "Size:"*)
        current_size="$(echo "$line" | awk '{print $2}')"
        ;;
      "Capabilities:"*)
        current_caps="${line#Capabilities:}"
        ;;
    esac

    if [ -n "$current_id" ] && [ -n "$current_size" ] && [ -n "$current_caps" ]; then
      if [[ "$current_caps" =~ (touch|tablet) ]] && [[ "$current_id" =~ ^i2c: ]]; then
        if [ -z "${id_seen[$current_id]:-}" ]; then
          local w h area
          w="${current_size%x*}"
          h="${current_size#*x}"
          if [[ "$w" =~ ^[0-9]+$ ]] && [[ "$h" =~ ^[0-9]+$ ]]; then
            area=$((w * h))
            id_area[$current_id]="$area"
            id_seen[$current_id]=1
          fi
        fi
      fi
    fi
  done < <(libinput list-devices 2>/dev/null)

  if [ "${#id_area[@]}" -lt 2 ]; then
    return
  fi

  local biggest_id=""
  local smallest_id=""
  local biggest_area=0
  local smallest_area=99999999
  local id area
  for id in "${!id_area[@]}"; do
    area="${id_area[$id]}"
    if [ "$area" -gt "$biggest_area" ]; then
      biggest_area="$area"
      biggest_id="$id"
    fi
    if [ "$area" -lt "$smallest_area" ]; then
      smallest_area="$area"
      smallest_id="$id"
    fi
  done

  if [ -n "$biggest_id" ] && [ -n "$smallest_id" ] && [ "$biggest_id" != "$smallest_id" ]; then
    top_touch_ids=("${biggest_id#i2c:}")
    bottom_touch_ids=("${smallest_id#i2c:}")
  fi
}

function detect_monitor_ids {
  local info
  info="$(mutter-helper monitor-ids 2>/dev/null)" || return
  if [ -z "$info" ]; then
    return
  fi

  local role connector vendor product serial
  while read -r role connector vendor product serial; do
    case "$role" in
      top)
        top_monitor_connector="$connector"
        top_monitor_vendor="$vendor"
        top_monitor_product="$product"
        top_monitor_serial="$serial"
        ;;
      bottom)
        bottom_monitor_connector="$connector"
        bottom_monitor_vendor="$vendor"
        bottom_monitor_product="$product"
        bottom_monitor_serial="$serial"
        ;;
    esac
  done <<< "$info"
}
function pick-source-backlight {
  if [ -d /sys/class/backlight/intel_backlight ]; then
    echo intel_backlight
    return
  fi

  for path in /sys/class/backlight/*; do
    echo "$(basename "$path")"
    return
  done
}

function pick-target-backlight {
  for candidate in asus_screenpad card1-eDP-2-backlight card0-eDP-2-backlight; do
    if [ -d "/sys/class/backlight/$candidate" ]; then
      echo "$candidate"
      return
    fi
  done

  for path in /sys/class/backlight/*; do
    name="$(basename "$path")"
    if [ "$name" != "intel_backlight" ]; then
      echo "$name"
      return
    fi
  done

  echo intel_backlight
}

source_backlight="$(pick-source-backlight)"
backlight="$(pick-target-backlight)"
backlight_state_file="/tmp/duo-bottom-backlight"
backlight_power_file="/tmp/duo-bottom-bl-power"

function find_bottom_connector_path {
  for path in /sys/class/drm/card*-DP-*/status; do
    if [ -f "$path" ]; then
      echo "${path%/status}"
      return
    fi
  done
}

function bottom_connector_on {
  if [ "${DUO_DRM_TOGGLE:-0}" != "1" ]; then
    return
  fi
  local conn
  conn="$(find_bottom_connector_path)"
  if [ -n "$conn" ]; then
    if [ -f "$conn/power/control" ]; then
      sysfs_write "$conn/power/control" on
    fi
    if [ -f "$conn/enabled" ]; then
      sysfs_write "$conn/enabled" enabled
    fi
    if [ -f "$conn/dpms" ]; then
      sysfs_write "$conn/dpms" On
    fi
  fi
}

function bottom_connector_off {
  if [ "${DUO_DRM_TOGGLE:-0}" != "1" ]; then
    return
  fi
  local conn
  conn="$(find_bottom_connector_path)"
  if [ -n "$conn" ]; then
    if [ -f "$conn/dpms" ]; then
      sysfs_write "$conn/dpms" Off
    fi
    if [ -f "$conn/enabled" ]; then
      sysfs_write "$conn/enabled" disabled
    fi
    if [ -f "$conn/power/control" ]; then
      sysfs_write "$conn/power/control" auto
    fi
  fi
}

function bottom_backlight_supported {
  [ "$backlight" != "$source_backlight" ]
}

function bottom_backlight_off {
  if ! bottom_backlight_supported; then
    return
  fi

  local path="/sys/class/backlight/$backlight/brightness"
  local bl_power="/sys/class/backlight/$backlight/bl_power"
  if [ -f "$path" ]; then
    cat "$path" > "$backlight_state_file"
    sysfs_write "$path" 0
  fi
  if [ -f "$bl_power" ]; then
    cat "$bl_power" > "$backlight_power_file"
    sysfs_write "$bl_power" 4
  fi
}

function bottom_backlight_restore {
  if ! bottom_backlight_supported; then
    return
  fi

  local path="/sys/class/backlight/$backlight/brightness"
  local bl_power="/sys/class/backlight/$backlight/bl_power"
  local restored=0
  if [ -f "$backlight_state_file" ]; then
    local saved
    saved="$(cat "$backlight_state_file")"
    if [ -n "$saved" ] && [ "$saved" -gt 0 ]; then
      sysfs_write "$path" "$saved"
      restored=1
    fi
  fi
  if [ "$restored" -eq 0 ]; then
    "$0" sync-backlight
  fi
  if [ -f "$bl_power" ]; then
    if [ -f "$backlight_power_file" ]; then
      sysfs_write "$bl_power" "$(cat "$backlight_power_file")"
    else
      sysfs_write "$bl_power" 0
    fi
  fi

  # Ensure bottom panel matches top after wake.
  "$0" sync-backlight
}

function bottom_backlight_is_off {
  if ! bottom_backlight_supported; then
    return 1
  fi

  local bl_power="/sys/class/backlight/$backlight/bl_power"
  local brightness="/sys/class/backlight/$backlight/brightness"
  if [ -f "$bl_power" ] && [ "$(cat "$bl_power")" = "4" ]; then
    return 0
  fi
  if [ -f "$brightness" ] && [ "$(cat "$brightness")" = "0" ]; then
    return 0
  fi
  return 1
}

function have-gnome-monitor-config {
  command -v gnome-monitor-config > /dev/null 2>&1
}

function mutter-helper {
  local script
  script="$(dirname "$(realpath "$0")")/duo_mutter.py"
  if [ "$(id -u)" -eq 0 ] && [ -n "${DUO_RUN_AS_USER:-}" ]; then
    local uid
    uid="$(id -u "$DUO_RUN_AS_USER" 2>/dev/null)"
    if [ -n "$uid" ]; then
      if [ -n "${DUO_MUTTER_UI_SCALE:-}" ] || [ -n "${DUO_MUTTER_Y_OFFSET:-}" ]; then
        DUO_UI_SCALE="${DUO_MUTTER_UI_SCALE:-}" DUO_Y_OFFSET="${DUO_MUTTER_Y_OFFSET:-}" \
          XDG_RUNTIME_DIR="/run/user/$uid" \
          DBUS_SESSION_BUS_ADDRESS="unix:path=/run/user/$uid/bus" \
          runuser -u "$DUO_RUN_AS_USER" -- python3 "$script" "$@"
      else
        XDG_RUNTIME_DIR="/run/user/$uid" \
          DBUS_SESSION_BUS_ADDRESS="unix:path=/run/user/$uid/bus" \
          runuser -u "$DUO_RUN_AS_USER" -- python3 "$script" "$@"
      fi
      return
    fi
  fi

  if [ -n "${DUO_MUTTER_UI_SCALE:-}" ] || [ -n "${DUO_MUTTER_Y_OFFSET:-}" ]; then
    DUO_UI_SCALE="${DUO_MUTTER_UI_SCALE:-}" DUO_Y_OFFSET="${DUO_MUTTER_Y_OFFSET:-}" \
      python3 "$script" "$@"
  else
    python3 "$script" "$@"
  fi
}

# 1080p model
#preferred_resolution="1920x1200@60.003"
#backlight=card1-eDP-2-backlight
#ui_scale=1
#y_offset=1200

function suenv {
  sudo /usr/bin/env "$@"
}

function sysfs_write {
  local path="$1"
  local value="$2"
  if [ -w "$path" ]; then
    echo "$value" > "$path"
  elif [ -w "$(dirname "$path")" ]; then
    echo "$value" | sudo -n /usr/bin/env tee "$path" > /dev/null 2>&1
  fi
}

function clamp_backlight_value {
  local value="$1"
  local max_path="/sys/class/backlight/$backlight/max_brightness"
  if [ -f "$max_path" ]; then
    local max
    max="$(cat "$max_path")"
    if [ -n "$max" ] && [ "$value" -gt "$max" ]; then
      echo "$max"
      return
    fi
  fi
  echo "$value"
}

function resolve_bat_limit {
  local arg="${1:-}"
  case "$arg" in
    ""|safe)
      echo 80
      return
      ;;
    full)
      echo 100
      return
      ;;
  esac

  if [[ "$arg" =~ ^[0-9]+$ ]] && [ "$arg" -ge 1 ] && [ "$arg" -le 100 ]; then
    echo "$arg"
    return
  fi

  return 1
}

function external-display-connected {
  if have-gnome-monitor-config; then
    [ "$(gnome-monitor-config list|grep display-name|grep -v 'Built-in display'|wc -l)" != "0" ]
  else
    [ "$(mutter-helper external-display-connected)" = "yes" ]
  fi
}

function active-external-displays {
  if have-gnome-monitor-config; then
    gnome-monitor-config list|grep -vE 'eDP-[12]'|sed -nE 's/Monitor \[ (.+) \] ON/\1/p'
  else
    mutter-helper active-external-displays
  fi
}

function keyboard-is-attached {
  lsusb|grep 0b05:1b2c
}

function set_peripheral_output {
  local type="$1"
  local device_id="$2"
  local output="$3"
  local vendor="$4"
  local product="$5"
  local serial="$6"
  local value
  value="['${vendor}', '${product}', '${serial}', '${output}']"

  # GNOME 46+ uses relocatable schemas under org.gnome.desktop.peripherals.*
  gsettings set "org.gnome.desktop.peripherals.${type}:/org/gnome/desktop/peripherals/${type}/${device_id}/" \
    output "$value" 2>/dev/null && return

  # Older setups used non-relocatable dconf paths under .../touchscreens and .../tablets
  dconf write "/org/gnome/desktop/peripherals/${type}s/${device_id}/output" "$value" 2>/dev/null
}

case "$1" in
  watch-displays)
    "$0" normal
    while inotifywait -e attrib /dev/bus/usb/*/ ; do
      if ! external-display-connected; then
        "$0" normal
      fi
    done
    ;;
  set-displays)
    if ! external-display-connected; then 
      "$0" normal
    fi
    ;;
  normal|bottom-up)
    if keyboard-is-attached; then
      "$0" top
    else
      "$0" both
    fi
    ;;
  top)
    bottom_connector_off
    if have-gnome-monitor-config; then
      gnome-monitor-config set \
        -LpM eDP-1 -m $preferred_resolution  -s $ui_scale -x 0 -y 0
    else
      # Keep bottom display in layout to avoid it disconnecting in DRM.
      mutter-helper both
    fi
    bottom_backlight_off
    ;;
  both)
    bottom_connector_on
    if have-gnome-monitor-config; then
      gnome-monitor-config set \
        -LpM eDP-1 -m $preferred_resolution -s $ui_scale -x 0 -y 0 \
        -LM  eDP-2 -m $preferred_resolution -s $ui_scale -x 0 -y $y_offset
    else
      mutter-helper both
    fi
    bottom_backlight_restore
    ;;
  bottom)
    bottom_connector_on
    if have-gnome-monitor-config; then
      gnome-monitor-config set \
        -LpM eDP-2 -m $preferred_resolution -s $ui_scale -x 0 -y 0
    else
      mutter-helper bottom
    fi
    bottom_backlight_restore
    ;;
  left-up)
    if have-gnome-monitor-config; then
      gnome-monitor-config set \
        -LpM eDP-2 -m $preferred_resolution -s $ui_scale -t left  -x 0         -y 0 \
        -LM  eDP-1 -m $preferred_resolution -s $ui_scale -t left  -x $y_offset -y 0
    else
      mutter-helper left-up
    fi
    ;;
  right-up)
    if have-gnome-monitor-config; then
      gnome-monitor-config set \
        -LM  eDP-1 -m $preferred_resolution -s $ui_scale -t right -x 0         -y 0 \
        -LpM eDP-2 -m $preferred_resolution -s $ui_scale -t right -x $y_offset -y 0
    else
      mutter-helper right-up
    fi
    ;;
  status-internal)
    if have-gnome-monitor-config; then
      internal_monitors="$(gnome-monitor-config list|grep -E "Monitor \\[ eDP-. \\] ON")"
      case "$(echo "$internal_monitors"|grep -v -E "^$"|wc -l)" in
        0) echo "none" ;;
        1) case "$(echo "$internal_monitors"|grep ON)" in
             "Monitor [ eDP-1 ] ON") echo top ;;
           esac ;;
        2) echo "both" ;;
      esac
    else
      status="$(mutter-helper status-internal)"
      if [ "$status" = "both" ] && bottom_backlight_is_off; then
        echo top
      else
        echo "$status"
      fi
    fi
    ;;
  status)
    (
      active-external-displays
    )|grep -vE "^$"|sed -z "s/\n/+/g"
    "$0" status-internal
    ;;
  toggle)
    if have-gnome-monitor-config; then
      if gnome-monitor-config list | grep OFF | grep eDP > /dev/null; then
        "$0" both
      else
        "$0" top
      fi
    else
      status="$(mutter-helper status-internal)"
      if [ "$status" = "both" ] && bottom_backlight_is_off; then
        status=top
      fi
      case "$status" in
        both) "$0" top ;;
        top) "$0" both ;;
        bottom) "$0" both ;;
        *) "$0" both ;;
      esac
    fi
    ;;
  set-tablet-mapping)
    detect_touch_ids
    detect_monitor_ids
    for type in tablet touchscreen; do
      for id in "${top_touch_ids[@]}"; do
        set_peripheral_output "$type" "$id" "$top_monitor_connector" \
          "$top_monitor_vendor" "$top_monitor_product" "$top_monitor_serial"
      done
      for id in "${bottom_touch_ids[@]}"; do
        set_peripheral_output "$type" "$id" "$bottom_monitor_connector" \
          "$bottom_monitor_vendor" "$bottom_monitor_product" "$bottom_monitor_serial"
      done
    done
    ;;
  toggle-bottom-touch)
    detect_touch_ids
    detect_monitor_ids
    for id in "${bottom_touch_ids[@]}"; do
      if gsettings writable "org.gnome.desktop.peripherals.touchscreen:/org/gnome/desktop/peripherals/touchscreen/${id}/" output >/dev/null 2>&1; then
        path="org.gnome.desktop.peripherals.touchscreen:/org/gnome/desktop/peripherals/touchscreen/${id}/"
        if [ -z "$(gsettings get "$path" output 2>/dev/null)" ] || [ "$(gsettings get "$path" output 2>/dev/null)" = "'[]'" ]; then
          gsettings set "$path" output "['${bottom_monitor_vendor}', '${bottom_monitor_product}', '${bottom_monitor_serial}', '${bottom_monitor_connector}']"
        else
          gsettings reset "$path" output
        fi
      else
        legacy_path="/org/gnome/desktop/peripherals/touchscreens/${id}/output"
        if [ -z "$(dconf read "$legacy_path" 2>/dev/null)" ]; then
          dconf write "$legacy_path" "['${bottom_monitor_vendor}', '${bottom_monitor_product}', '${bottom_monitor_serial}', '${bottom_monitor_connector}']"
        else
          dconf reset "$legacy_path"
        fi
      fi
    done
    ;;
  bat-limit)
    limit="$(resolve_bat_limit "${2:-}")" || {
      echo "Invalid battery limit: ${2:-}" >&2
      echo "Usage: duo bat-limit [safe|full|1-100]" >&2
      exit 1
    }
    echo "$limit" | suenv tee /sys/class/power_supply/BAT0/charge_control_end_threshold
    ;;
  bat-safe)
    "$0" bat-limit safe
    ;;
  bat-full)
    "$0" bat-limit full
    ;;
  sync-backlight)
    value="$(cat "/sys/class/backlight/$source_backlight/brightness")"
    sysfs_write "/sys/class/backlight/$backlight/brightness" \
      "$(clamp_backlight_value "$value")"
    ;;
  set-kb-backlight)
    suenv python3 bk.py "$2"
    ;;
  watch-backlight)
    "$0" sync-backlight
    while inotifywait -e modify "/sys/class/backlight/$source_backlight/brightness" ; do
      "$0" sync-backlight
    done
    ;;
  *) echo "Usage: duo <top|bottom|both|set-displays|toggle|status|set-tablet-mapping|bat-limit|bat-safe|bat-full|sync-backlight|set-kb-backlight|watch-backlight|watch-displays>"
esac
